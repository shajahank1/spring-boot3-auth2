# PKCE
Proof Key for Code Exchange (PKCE, pronounced "pixy") is an extension to the OAuth 2.0 Authorization Code flow. It was designed to make the authorization process more secure, especially for public clients like single-page applications (SPAs) and mobile apps that cannot securely store a client secret. Here’s how PKCE works:

1. Overview
The primary purpose of PKCE is to protect against authorization code interception attacks by adding an additional layer of security. It achieves this by having the client generate a "code verifier" and a "code challenge" that must be used in the token exchange process.

2. How PKCE Works
Here’s a step-by-step breakdown of the PKCE flow:

Step 1: Generate the Code Verifier and Code Challenge
Code Verifier: A high-entropy cryptographically random string (between 43 and 128 characters long). This string is generated by the client (your Angular app).
Code Challenge: Derived from the code verifier using either of the following methods:
plain: The code challenge is simply the code verifier.
S256: The code verifier is hashed using SHA-256, and the resulting string is base64-url encoded to create the code challenge. This is the preferred and more secure method.
Step 2: Authorization Request
When the user initiates the login process, the client (your app) redirects the user to the authorization server with the following parameters:

response_type=code: Indicates the Authorization Code flow.
client_id: Your client application's ID.
redirect_uri: The URI where the authorization server will redirect back to your app.
code_challenge: The code challenge generated in step 1.
code_challenge_method: Indicates whether "plain" or "S256" was used for generating the code challenge.
Example Authorization Request URL:

arduino
Copy code
https://auth-server.com/authorize?response_type=code
&client_id=your-client-id
&redirect_uri=https://your-app.com/callback
&code_challenge=base64urlencoded_code_challenge
&code_challenge_method=S256
Step 3: User Authenticates
The user authenticates with the authorization server (using their username and password or other mechanisms like 2FA).
Step 4: Authorization Code Returned
If authentication is successful, the authorization server redirects the user back to your app's redirect_uri with an authorization code in the URL query string.
Example:

arduino
Copy code
https://your-app.com/callback?code=authorization_code
Step 5: Token Exchange with PKCE
Your app now exchanges the authorization code for an access token by making a POST request to the authorization server's /token endpoint. In this request, it sends:
client_id: Your client ID
grant_type=authorization_code: Indicates the Authorization Code grant type
code: The authorization code received in the previous step
redirect_uri: The same redirect URI used in the authorization request
code_verifier: The original code verifier generated in step 1
Example Token Request:

makefile
Copy code
POST /token
Host: auth-server.com
Content-Type: application/x-www-form-urlencoded

client_id=your-client-id
&grant_type=authorization_code
&code=authorization_code_received
&redirect_uri=https://your-app.com/callback
&code_verifier=code_verifier_generated
Step 6: Authorization Server Verifies the Code Verifier
The authorization server verifies the code_verifier by checking if it matches the code_challenge sent during the authorization request.
If valid, the authorization server issues an access token (and potentially a refresh token) to your app.
3. Benefits of PKCE
Protection Against Code Interception: The code_verifier ensures that even if an attacker intercepts the authorization code, they cannot exchange it for a token without having the original code_verifier.
No Need for Client Secrets: Since the client doesn't have to store a secret, this is ideal for public clients like SPAs and mobile apps.
4. Why PKCE is Important
PKCE was initially introduced to secure mobile apps but is now recommended for all OAuth 2.0 clients, including single-page and traditional web applications. It provides an additional layer of security by mitigating the risks associated with the interception of authorization codes.

Summary
PKCE makes the OAuth 2.0 Authorization Code flow more secure by requiring the code_verifier in the token exchange step.
It prevents attackers from using intercepted authorization codes without access to the code_verifier.
It’s easy to implement and doesn’t require storing any client secrets, making it ideal for SPAs and mobile applications.
